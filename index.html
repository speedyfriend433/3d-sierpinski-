<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Spinning 3D Sierpinski Tetrahedron</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <!-- Load Three.js from a CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
      // Set up the scene, camera, and renderer
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.z = 4;

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Array to accumulate vertex positions for all triangles
      const positions = [];

      // Function to add a tetrahedron's faces (as triangles) to the positions array
      function addTetrahedron(v0, v1, v2, v3) {
        // Each tetrahedron has 4 faces (triangles)
        // Face 1
        positions.push(...v0.toArray(), ...v1.toArray(), ...v2.toArray());
        // Face 2
        positions.push(...v0.toArray(), ...v3.toArray(), ...v1.toArray());
        // Face 3
        positions.push(...v0.toArray(), ...v2.toArray(), ...v3.toArray());
        // Face 4
        positions.push(...v1.toArray(), ...v3.toArray(), ...v2.toArray());
      }

      // Recursive function to build the Sierpinski tetrahedron
      function sierpinski(v0, v1, v2, v3, depth) {
        if (depth === 0) {
          addTetrahedron(v0, v1, v2, v3);
        } else {
          // Compute midpoints of each edge
          const v01 = new THREE.Vector3().addVectors(v0, v1).multiplyScalar(0.5);
          const v02 = new THREE.Vector3().addVectors(v0, v2).multiplyScalar(0.5);
          const v03 = new THREE.Vector3().addVectors(v0, v3).multiplyScalar(0.5);
          const v12 = new THREE.Vector3().addVectors(v1, v2).multiplyScalar(0.5);
          const v13 = new THREE.Vector3().addVectors(v1, v3).multiplyScalar(0.5);
          const v23 = new THREE.Vector3().addVectors(v2, v3).multiplyScalar(0.5);

          // Create 4 smaller tetrahedra at each vertex
          sierpinski(v0, v01, v02, v03, depth - 1);
          sierpinski(v1, v01, v12, v13, depth - 1);
          sierpinski(v2, v02, v12, v23, depth - 1);
          sierpinski(v3, v03, v13, v23, depth - 1);
        }
      }

      // Define the vertices of the initial (regular) tetrahedron
      const v0 = new THREE.Vector3( 1,  1,  1);
      const v1 = new THREE.Vector3(-1, -1,  1);
      const v2 = new THREE.Vector3(-1,  1, -1);
      const v3 = new THREE.Vector3( 1, -1, -1);

      // Set the recursion depth (adjust for more/less detail)
      const depth = 3;
      sierpinski(v0, v1, v2, v3, depth);

      // Create a BufferGeometry and add the computed vertices
      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      geometry.computeVertexNormals();

      // Use a MeshNormalMaterial for a colorful, shaded look.
      const material = new THREE.MeshNormalMaterial({
        side: THREE.DoubleSide,
        flatShading: true,
      });

      // Create the mesh and add it to the scene
      const mesh = new THREE.Mesh(geometry, material);
      scene.add(mesh);

      // Animation loop: rotate the mesh and render the scene
      function animate() {
        requestAnimationFrame(animate);
        mesh.rotation.x += 0.005;
        mesh.rotation.y += 0.01;
        renderer.render(scene, camera);
      }
      animate();

      // Update renderer and camera on window resize
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
